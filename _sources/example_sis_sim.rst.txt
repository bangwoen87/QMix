
A Simple Example
================

This example will determine the tunneling currents in an SIS junction
based on the voltage applied across the junction (i.e., the junction
drive level, :math:`\alpha`). This example assumes that the voltage
across the junction is constant and already known (harmonic balance is
not needed).

.. code:: ipython2

    %matplotlib inline  
    import matplotlib.pyplot as plt
    import numpy as np

.. code:: ipython2

    import qmix
    from qmix.constants import MILLI, GIGA, ECHARGE, PLANCK

Define junction properties
~~~~~~~~~~~~~~~~~~~~~~~~~~

Basic electrical properties of the SIS junction.

.. code:: ipython2

    v_gap = 2.8 * MILLI               # gap voltage in [V]
    r_n = 14                          # normal resistance in [ohms]
    f_gap = ECHARGE * v_gap / PLANCK  # gap frequency in [Hz]

Define circuit parameters
~~~~~~~~~~~~~~~~~~~~~~~~~

Basic electrical properties of the embedding circuit

**Note:** In all of the reference papers, the first frequency is listed
as f=1 and the first harmonic is listed as p=1. Numpy arrays are
0-based, but for the circuit parameters, I have designed this package to
have the first entry start at index=1.

**Note:** This example doesn't include the embedding impedance since it
assumes you already know the junction voltage.

.. code:: ipython2

    # number of tones/frequencies (f)
    num_f = 1
    
    # number of harmonics (p)
    num_p = 1
    
    # signal frequency (unnormalized)
    f_sig = 230 * GIGA
    
    # create new instance of embedding circuit
    cct = qmix.circuit.EmbeddingCircuit(num_f, num_p)
    
    # photon voltage:  vph[f] in R^(num_f+1)
    cct.vph[1] = f_sig / f_gap
    
    # voltage across junction:  vj[f, p, vb] in C^(num_f+1, num_p+1, npts)
    vj = cct.initialize_vj()
    alpha = 1.2
    vj[1, 1, :] = cct.vph[1] * alpha

Define simulation parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The number of Bessel functions to include: num\_b - Ideally we would
include an infinite number of Bessel functions, but practically, we need
to truncate this number somewhere. This number depends on the number of
tones and the signal strengths. Typically num\_b=8 is okay for a single
tone with alpha < 2. num\_b=15 is okay for multiple tones with alpha <
2. - This is essentially how many absorbed photons will be considered.
See Kennedy's or Kittara's thesis for more info. - num\_b can either be
single integer (in which case the same number of bessel functions will
be used for each tone), or it can be a tuple with one entry for each
tone.

.. code:: ipython2

    # number of Bessel functions
    num_b = 15

Load desired response function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Among other properties, this class contains: - the characteristic I-V
curve, - its Kramers-Kronig transform, and - the cubic spline fits to
allow for quick interpolation.

In this example, the response function is based of the polynomial I-V
curve model from Kennedy's thesis.

.. code:: ipython2

    p_order = 50
    resp = qmix.respfn.RespFnPolynomial(p_order)


Calculate desired tunnelling currents
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Note:** The tunneling current function will only solve for the
tunneling currents at the desired frequencies. You determine which
currents you would like to solve for by listing their photon voltages in
vph\_list.

E.g., if you want to solve for the DC current and the AC current at
frequency=f\_sig, your vph\_list would be:

::

      vph_list = [0, f_sig/f_gap]

Then, the output current will correspond to the order of vph\_list:

-  ``current[0,:]`` corresponds to ``vph_list[0]`` (i.e., f=0), and

-  ``current[1,:]`` corresponds to ``vph_list[1]`` (i.e., f=f\_sig).

.. code:: ipython2

    vph_list = [0, cct.vph[1]]  
    current = qmix.mixer_current.mixer_current(vph_list, vj, cct, resp, num_b)


.. parsed-literal::

    
    Calculating tunneling current...
     - 1 tone(s)
    Done.
    Time: 0.01 s


Post-processing
~~~~~~~~~~~~~~~

Plot DC and AC currents

.. code:: ipython2

    plt.rc('axes', labelsize='large', titlesize='large')
    plt.rc('xtick', labelsize='large')
    plt.rc('ytick', labelsize='large')
    plt.rc('lines', linewidth=3)
    
    # plot pumped i-v curve
    plt.figure(figsize=(5,5))
    plt.plot(resp.voltage, resp.current_dc0, label='DC I-V')
    plt.plot(cct.vb, np.real(current[0, :]), label='Pumped I-V')
    plt.legend(loc='best', frameon=False)
    plt.xlabel('Bias Voltage')
    plt.ylabel('DC Current')
    plt.title('DC Currents')
    plt.ylim([0, 2])
    plt.xlim([0, 2])


.. image:: _images/output_14_1.png


.. code:: ipython2

    # plot ac tunnelling current
    plt.figure(figsize=(5,5))
    plt.plot(cct.vb, np.abs(current[1, :]), label='Abs')
    plt.plot(cct.vb, np.real(current[1, :]), label='Real')
    plt.plot(cct.vb, np.imag(current[1, :]), label='Imaginary')
    plt.legend(loc='best', frameon=False)
    plt.xlabel('Bias Voltage')
    plt.ylabel('AC Current')
    plt.title(r'AC Current @ $f = f_{sig}$')
    plt.ylim([-1, 1.5])
    plt.xlim([0, 2])

.. image:: _images/output_15_1.png


