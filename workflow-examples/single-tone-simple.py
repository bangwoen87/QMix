""" single-tone-simple.py

- This simulation is very simple:
    - The input consists of only one tone
    - The embedding impedance is ignored (no harmonic balance)
    - The DC I-V curve is generated by a polynomial model

- This simulation calculates:
    - the pumped I-V curve
    - the AC tunnelling currents
    - the AC admittance
    - the AC power delivered to the junction

- These are plotted and saved as 'single-tone-simple.pdf'

"""

import qmix
import numpy as np
import matplotlib.pyplot as plt

# see: https://github.com/garrettj403/SciencePlots/
# plt.style.use(['science'])

qmix.print_intro()

blue = '#0C5DA5'
red = '#FF2C00'

# Define the embedding circuit properties ------------------------------------
# note: 
#    - All of the circuit properties are normalized: voltages are normalized
#      to the gap voltage, resistances to the normal resistance,
#      currents to (vgap / rn), and frequencies to the gap frequency (fgap).
#    - This example doesn't include the embedding impedance -- it assumes
#      you already know the junction voltage.

num_f = 1  # number of frequencies
num_p = 1  # number of harmonics

# create instance of embedding circuit class
cct = qmix.circuit.EmbeddingCircuit(num_f, num_p)

# set normalised frequency
cct.vph[1] = 0.33

# set junction voltage (set alpha = 1)
vj = cct.initialize_vj()
vj[1, 1, :] = cct.vph[1] * 1.

# Load desired response function ---------------------------------------------

# use polynomial I-V curve model to generate response function
resp = qmix.respfn.RespFnPolynomial(50)

# Calculate desired tunnelling currents --------------------------------------
# note: The qtcurrent function will only solve for the desired
#       tunnelling currents. You specify which currents you would like by
#       listing their photon voltages in a list. E.g., if you want to solve
#       for the DC current and the AC current at f=f_lo, your list would
#       be:
#           vph_list = [0, f_lo/fgap]
#       Then, the output current will correspond to the order of vph_list:
#           current[0] corresponds to vph=0 (i.e., f=0), and
#           current[1] corresponds to vph=f_lo/fgap (i.e., f=f_lo).

vph_list = [0, cct.vph[1]]
current = qmix.qtcurrent.qtcurrent(vj, cct, resp, vph_list)
idc = current[0].real
iac = current[1]

# Plotting -------------------------------------------------------------------
# note: This can be thought of as post-processing. All the work is done now.
#       For a large simulation, this should probably be in a separate file.

voltage_label = r'Bias Voltage / $V_\mathrm{{gap}}$'
current_label = r'DC Current / $I_\mathrm{{gap}}$'
ac_current_label = r'AC Current / $I_\mathrm{{gap}}$'
admittance_label = r'AC Admittance / $G_\mathrm{{n}}$'
power_label = r'AC Power / $P_\mathrm{{gap}}$'

fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(8,7))
plt.subplots_adjust(wspace = 0.4)

# plot pumped i-v curve
# vertical lines for photon steps
for i in range(-10,10):
    ax1.axvline(1 - i * cct.vph[1], c='gray', ls='--', lw=0.5)
# plot I-V data
ax1.plot(resp.voltage, resp.current, label='Unpumped')
ax1.plot(cct.vb, idc, 'r', label='Pumped')
# label the steps
for i, lbl in zip(range(3), ['1st', '2nd', '3rd']):
    vtmp = 1 - (i + 0.5) * cct.vph[1]
    itmp = np.interp(vtmp, cct.vb, idc)
    ax1.annotate("{}\nstep".format(lbl), 
                 xy=(vtmp, itmp+0.15), 
                 xytext=(vtmp, itmp+0.15),
                 va='center', ha='center', 
                 fontsize=7)
# hw/e label
ax1.text(1-cct.vph[1]/2, 1.1, r'$\hbar\omega/e$', fontsize=8, ha='center', va='bottom')
ax1.annotate("", xy=(1-cct.vph[1], 1), xytext=(1, 1), 
    arrowprops=dict(arrowstyle="<->", color='k'))
# other labels
ax1.set(xlabel=voltage_label, xlim=[0,2])
ax1.set(ylabel=current_label, ylim=[0,2])
ax1.legend(frameon=True)

# plot ac currents
ax2.plot(cct.vb, np.abs(iac), 'k--', label=r'Absolute')
ax2.plot(cct.vb, np.real(iac), c=blue, label=r"Real")
ax2.plot(cct.vb, np.imag(iac), c=red, label=r"Imaginary")
ax2.set(xlabel=voltage_label, xlim=[0,2])
ax2.set(ylabel=ac_current_label, ylim=[-1,1.2])
ax2.legend(frameon=False)

# plot ac admittance
y = current[1] / vj[1, 1]
ax3.plot(cct.vb, np.abs(y), 'k--', label=r'Absolute')
ax3.plot(cct.vb, np.real(y), c=blue, label=r'Real')
ax3.plot(cct.vb, np.imag(y), c=red, label=r'Imaginary')
ax3.set(xlabel=voltage_label, xlim=[0,2])
ax3.set(ylabel=admittance_label)
ax3.legend(frameon=False)

# plot ac power delivered to junction
ax4.plot(cct.vb, 0.5 * np.real(vj[1,1] * np.conj(iac)))
ax4.set(xlabel=voltage_label, xlim=[0,2])
ax4.set(ylabel=power_label, ylim=[0,0.15])

plt.tight_layout()

fig.savefig('single-tone-simple.png', dpi=500)
